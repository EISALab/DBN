/////////////////////////////////////////////////////////////
//
//  bayesian_adet.cc
//  11.01.2006 djhill1 created
//
/////////////////////////////////////////////////////////////

#include "bayesian_adet.h"

int BAYES_ADET(int argc, char **argv, ostream& errMsg){
  errMsg << "\n\nRun Bayesian Anomaly Detection\n";
  //errMsg << "[task]"\n; //argv[1]
  errMsg << "-kalman: use kalman filter\n";
  errMsg << "-rbpf: use Rao-Blackwellized particle filter\n";
  errMsg << "-rbpf2: use Rao-Blackwellized particle filter that allows multiple discrete variables\n";
  errMsg << "-m [fname]: model specification file\n";
  errMsg << "-f [fname]: Name of file containing data. \n";
  errMsg << "-z [value]: Value for credible interval (80% = 1.645, 95% = 1.96, 99% = 2.576, 99.9% = 3.291)\n";
  errMsg << "-u: [Number of data columns] [use column_0 0/1] ... [use column_n 0/1] \n";
  errMsg << "-L [number of EM iterations]: learn new filter parameters\n";
  errMsg << "-C <fname>: create cleaned datafile\n";
  errMsg << "-r [int]: number of missing values before restarting filter\n";
  errMsg << "-data_res [int]: data resolution in seconds (default 1)\n";
  errMsg << "-data_res_int [int]: data resolution interval in seconds (default 0)\n";
  errMsg << "-err: data file contains error classifications\n";
  errMsg << "\n";
  stringstream inputLine;
  int restartGapLength = -1;
  int mType = 0;
  string mSpec = "model.dat";
  string ifile_name = "data.csv";
  double z_val = 2.576;
  vector< int > useIdx( 1, 1 );
  bool learn=false;
  int learnIter=10;
  bool clean=false;
  string cleanFile;
  int data_resolution = 1;
  int data_resolution_range = 0;
  bool errFlag = false;
  for( int i=2; i< argc; i++ ) inputLine << "  " << argv[i];
  //cout << inputLine.str() << endl;
  int nObs = 0;
  string flag;
  while( inputLine >> flag ){
    //cout << flag;
    if( flag == "-kalman" ) mType = 0;
    else if( flag == "-rbpf" ) mType = 1;
    else if( flag == "-rbpf2" ) mType = 2;
    else if( flag == "-m" ) inputLine >> mSpec;
    else if( flag == "-f" ) inputLine >> ifile_name;
    else if( flag == "-z" ) inputLine >> z_val;
    else if( flag == "-u" ){
      int nvar;
      inputLine >> nvar;
      useIdx = vector< int >( nvar, 1 );
      for( int i=0; i< nvar; i++ ) inputLine >> useIdx[i];
    }
    else if( flag == "-L" ){
      learn=true;
      inputLine >> learnIter;
      cout << "# Learning new kf params using " << learnIter << " EM iterations\n";
    }
    else if( flag == "-C" ){
      clean=true;
      cout << "Creating Cleaned data file\n";
      inputLine >> cleanFile;
    }
    else if( flag == "-r" ){
      inputLine >> restartGapLength;
      cout << "# Filter will be restarted after " << restartGapLength << "missing values\n";
    }
    else if( flag == "-data_res" ){
      inputLine >> data_resolution;
      cout << "# Data resolution is " << data_resolution << " seconds\n";
    }
    else if( flag == "-data_res_int" ){
      inputLine >> data_resolution_range;
      cout << "# Data resolution interval is +-(" << data_resolution_range << "sec.)\n";
    }
    else if( flag == "-err" ) errFlag = true;
    else{
      errMsg << "Illegal flag: \"" << flag << "\"... aborting" << endl;
      return( 0 );
    }
  }
  cout << "# Model type: ";
  if( mType == 0 ) cout << "Kalman Filter" << endl;
  else if( mType == 1 ) cout << "Rao-Blackwellized particle filter" << endl;
  else if( mType == 2 ) cout << "Second Generation Rao-Blackwellized particle filter" << endl;
  cout << "# Using model specified in \"" << mSpec << "\""<< endl;
  cout << "# Inputfile is: " << ifile_name << endl;
  //
  ifstream ifile( ifile_name.c_str() );
  if( !ifile ) {
    errMsg << "ERROR: cannot open \"" << ifile_name << "\"... aborting\n";
    return( 0 );
  }
  cout << "# z_val is " << z_val << endl;
  cout << "# number of data columns: " << useIdx.size() << endl;
  cout << "# ( var index , use? )\n";
  ofstream clean_datafile;
  if( clean ){
    clean_datafile.open( cleanFile.c_str() );
    if( !clean_datafile ) {
      errMsg << "ERROR: cannot open \"" << cleanFile << "\"... aborting\n";
      return( 0 );
    }
  }
  for(int i=0; i< useIdx.size(); i++){
    cout << "# ( " << i << "," << useIdx[i] << " )" << endl;
    nObs += useIdx[i];
  }
  //
  cout << "# Reading Data" << endl;
  vector< ts_record > Records;
  if( GetRecords( ifile, Records ) != 1 ){
    errMsg << "ERROR: could not read records from " << argv[6] << "... aborting.\n";
    return( 0 );
  }
  ifile.close();
  cout << "# Read " << Records.size() << " records\n";
  //
  bayes_filter *model;
  string pfile_name = mSpec;
  
  if( mType == 0 ){
    cout <<"# Creating new Kalman Filter \n";
    model = new adet_kf( pfile_name );
  }
  else if( mType == 1 ){
    cout <<"# Creating new Rao-Blackwellized Particle Filter \n";
    model = new adet_rbpf( pfile_name );
  }
  else if( mType == 2 ){
    cout <<"# Creating new Second Generation Rao-Blackwellized Particle Filter \n";
    model = new adet_rbpf2( pfile_name );
  }
  else {
    cerr << "Error: Invalid model type... point A\n";
    return( 0 );
  }
  //model->Archive( cout );
  //
  vector< int > ErrCnt( nObs,0 );
  vector< int > ExampCnt( nObs, 0 );
  vector< int > falsePos( nObs, 0 );
  vector< int > falseNeg( nObs, 0 );
  vector< int > truePos( nObs, 0 );
  vector< int > trueNeg( nObs, 0 );
  int i = 0;
  //for( int i=0; i < Records.size(); i++ ){
  timestamp expectedTS = Records[0].TS();
  int gapLength = 0;
  vector< vector< ts_record > > trainingSet(1);
  //vector< ts_record > trainingSet;
  int Tset_idx = 0;
  while( i<Records.size() ){
    //cout << "# " << i << " " << Records.size() << endl;
    // define not a number
    double NaN;
    unsigned long nan[2]={0xffffffff, 0x7fffffff};
    NaN = *( double* )nan;
    //
    // IF LONG STRETCH OF DATA IS MISSING, QUIT AND RESTART
    if( restartGapLength > 0 && gapLength > restartGapLength ){
      // reset filter
      delete model;
      if( mType == 0 ) model = new adet_kf( pfile_name );
      else if( mType == 1 ) model = new adet_rbpf( pfile_name );
      else {
        cerr << "Error: Invalid model type... point A\n";
        return( 0 );
      }
      // RESET EXPECTED TIMESTAMP
      expectedTS = Records[i].TS();
      // RESET GAP DURATION
      gapLength=0;
      // Increment Tset_idx;
      Tset_idx++;
      trainingSet.push_back( vector< ts_record>() );
    }
    //
    // MAKE NEW OBSERVATION FROM RECORDS
    ts_record newObs;
    vector< double > labels;
    //cout << "Expected TS: " << expectedTS.Timestamp() << endl;
    //cout << expectedTS.NextIntervalSec( -data_resolution_range ).Timestamp() << " <= " 
    //     << Records[i].TS().Timestamp() 
    //     << " <= " << expectedTS.NextIntervalSec( data_resolution_range ).Timestamp() << endl;
    if( Records[i].TS() < expectedTS ) exit( -1 );
    if( expectedTS.NextIntervalSec( -data_resolution_range ) <= Records[i].TS() && 
        Records[i].TS() <= expectedTS.NextIntervalSec( data_resolution_range ) ){
    //cout << "# Making record from data\n";
    //if( Records[i].TS() == expectedTS ){
      // NEXT RECORD OCCURS AT EXPECTED TIME
      // Get observation from records
      vector< float > vals;
      int ExampCntIdx = 0;
      for( int j=0; j<useIdx.size(); j++ ){
        if( useIdx[j] == 1 ) {
          if( Records[i].Data()[j] == Records[i].NAFlag() ){
            vals.push_back( NaN );
          }
          else{
            vals.push_back( Records[i].Data()[j] );
            ExampCnt[ExampCntIdx]++;
          }
          ExampCntIdx++;
        }
      }
      newObs = ts_record( expectedTS, vals, NaN );
      //
      if( errFlag ){
        for( int j=useIdx.size(); j< 2*useIdx.size(); j++ ){
          if( useIdx[j-useIdx.size()] == 1 ){
            labels.push_back( Records[i].Data()[j] );
          }
        }
        //cout << "labels size: " << labels.size() << endl;
      }
      i++; // increment index
      gapLength = 0;  //reset gap length
    }
    else{
      // NEXT RECORD DOES NOT OCCUR AT EXPECTED TIME
      // create new observation of all NaN
      //cout << "# Making NaN record\n";
      vector< float > vals;
      for( int j=0; j<useIdx.size(); j++ ){
        if( useIdx[j] == 1 ){
          vals.push_back( NaN );
        }
      }
      if( errFlag ) labels = vector< double >( vals.size(), -1 );
      newObs = ts_record( expectedTS, vals, NaN );
      gapLength++;
    }
    // increment expected time timestamp
    //expectedTS = expectedTS.NextIntervalSec( 1 );
    //cout << "Increment Expected Timestamp " << expectedTS.Timestamp() << " -> ";
    expectedTS = expectedTS.NextIntervalSec( data_resolution );
    //cout << expectedTS.Timestamp() << endl;
    
    if( learn ){
      trainingSet[Tset_idx].push_back( newObs );
      //trainingSet.push_back( newObs );
      //cout << "# Pushed : ";
      //trainingSet[Tset_idx].back().PrintSSV( 1, cout );      
      //cout << "# Training Set size: " << trainingSet[Tset_idx].size() << endl;
    }
    else{
      // filter observation
      vector< vector< float > > result = model->Filter( newObs.Data(), z_val );
    
      //newObs.TS().PrintTimestamp(cout);
      //newObs.TS().PrintJulianDate(cout);
      for( int j=0; j<result.size(); j++ ){
        if( result[j][4] == 0 && !isnan( result[j][0] ) ){
          ErrCnt[j]++;
          if( errFlag ){
            //if( Records[i-1].Data()[ Records[i-1].Data().size() - result.size() + j ] == 0 ) truePos[j]++;
            //else if( Records[i].Data()[ Records[i].Data().size() - result.size() + j ] == 1 ) falsePos[j]++;
            if( labels[j] == 0 ) truePos[j]++;
            else if( labels[j] == 1 ) falsePos[j]++;
          }
        }
        if( result[j][4] == 1 && !isnan( result[j][1] ) ){
          if( errFlag ){
            //if( Records[i-1].Data()[ Records[i-1].Data().size() - result.size() + j ] == 1 ) trueNeg[j]++;
            //else if( Records[i].Data()[ Records[i].Data().size() - result.size() + j ] == 0 ) falseNeg[j]++;
            if( labels[ j ] == 1 ) trueNeg[j]++;
            else if( labels[ j ] == 0 ) falseNeg[j]++;
          }        
        }
        newObs.TS().PrintTimestamp(cout);
        newObs.TS().PrintJulianDate(cout);
        for( int k=0; k< result[j].size(); k++) {
          cout << setw(15) << result[j][k];
        }
        if( errFlag ) cout << setw(15) << labels[j];
        cout << endl;
        //if( result[j][4]==0 ) ErrCnt[j]++;
      }
      cout << endl << endl;  //gnuplot data blocks are seperated by 2 blank lines;
      if(clean){
        clean_datafile << newObs.TS().Timestamp();
        for( int j=0; j<result.size(); j++ ){
          clean_datafile << ",";
          if( result[j][4] == 0 && !isnan( result[j][0] ) ){
            clean_datafile << "NA";
          }
          else{
            clean_datafile << result[j][0];
          }
        }
        clean_datafile << endl;
      }
    }
  }
  if( learn ){
    cout << "# Training Set size: " << trainingSet.size() << endl;
    for( int t=0; t<trainingSet.size(); t++ ){
      cout << setw(5) << trainingSet[t].size();
    }
    cout << endl;
    model->Learn( trainingSet, learnIter );
    //cout << "\n\n\n\n#Learned Model Parameters\n";
    //model->Archive( cout );
  }
  else{
    for( int j=0; j< ErrCnt.size(); j++ ){
      cout << "# Obs " << j << " - Number of Examples: " << ExampCnt[j] 
      << " Number of Errors: " << ErrCnt[j]
      << " Number of Errors: " << 100.*float( ErrCnt[j] )/float( ExampCnt[j] ) << "%" << endl;
      if( errFlag ){
        cout << "# Number of True Positives: " << truePos[j] << " (" << float( truePos[j] )/float( truePos[j] + falseNeg[j] ) << ")\n";
        cout << "# Number of False Positives: " << falsePos[j] << " (" << float( falsePos[j] )/float( trueNeg[j] + falsePos[j] ) << ")\n";
        cout << "# Number of True Negatives: " << trueNeg[j] << " (" << float( trueNeg[j] )/float( trueNeg[j] + falsePos[j] ) << ")\n";
        cout << "# Number of False Negatives: " << falseNeg[j] << " (" << float( falseNeg[j] )/float( truePos[j] + falseNeg[j] ) << ")\n";
      }
    }
  }
  delete( model );
  return( 1 );
}

/////////////////////////////////////////////////////////////
//
//  class bayes_filter
//    generic bayesian filter
//
//  11.01.2006 djhill1 created
/////////////////////////////////////////////////////////////

bayes_filter::bayes_filter(){}
 
bayes_filter::bayes_filter( istream& stream ){}
    
bayes_filter::bayes_filter( const string& ){}
  

/////////////////////////////////////////////////////////////
//
//  class adet_kf
//    Kalman filter for anomaly detection
//
//  11.01.2006 djhill1 created
/////////////////////////////////////////////////////////////
adet_kf::adet_kf(): bayes_filter(), kalman_filter() { }
 
adet_kf::adet_kf( istream& stream ): bayes_filter(), kalman_filter( ){
  string arb; // arbitrary string constant
  stream >> arb >> arb;  // "Window Size"
  stream >> _maxWindowSize;
  stream >> _matrices;
  //this->Archive( cout );
}
    
adet_kf::adet_kf( const string& s ): bayes_filter(), kalman_filter( ) {
  //cout << "# Creating new adet_kf from file: " << s << endl;
  ifstream file( s.c_str() );
  if( !file ){
    cerr << "Cannot open file: " << s << endl;
    exit( -1 );
  }
  *this = adet_kf( file );
  file.close();
}
  
/*******************************************************
 *  Purpose: Update and calculate filtered estimate
 *    of system state
 *  
 *  Input: obs :- observation
 *         a :- Bayesian credible interval 
 *             (Bayesian Posterior Interval)
 *             scale arameter
 *
 *  11.01.2006 djhill1 created
 *  12.06.2006 djhill1 changed Bayesian Credible interval to use innovation covariance
 *******************************************************/
 vector< vector< float > > adet_kf::Filter( const vector< float >& obs, const float& a ) {
   matrix< double > obsMat( obs.size(), 1 );
   for( int i=0; i< obs.size(); i++ ){
     obsMat(i,0) = obs[i];
   }
   //cout << "New Observation: \n" << obsMat << endl;
   StepForward( obsMat );
   vector< vector< float > > returnVal( obs.size() );
   for( int i=0; i< returnVal.size(); i++ ){
     returnVal[i] = vector< float >( 5 );
     returnVal[i][0] = obs[i]; // observation(i)
     //returnVal[i][1] = CurrentMean()(i,0)-a*sqrt( CurrentCov()(i,i) ); // lower bound of observation(i)
     returnVal[i][1] = CurrentMean()(i,0)-a*sqrt( CurrentInnovationCov()(i,i) ); // lower bound of observation(i)
     returnVal[i][2] = CurrentMean()(i,0); // mean of observation(i)
     returnVal[i][3] = CurrentMean()(i,0)+a*sqrt( CurrentInnovationCov()(i,i) ); // upper bound of observation(i)
     //returnVal[i][3] = CurrentMean()(i,0)+a*sqrt( CurrentCov()(i,i) ); // upper bound of observation(i)
     if( returnVal[i][1] <= returnVal[i][0] && returnVal[i][0] <= returnVal[i][3] && !isnan( obs[i]) ){
       returnVal[i][4] = 1.;
     }
     else if( isnan( obs[i] ) ) returnVal[i][4] = -1.;
     else{
       returnVal[i][4] = 0.;
     }
   }
   return( returnVal );
 }

/*******************************************************
 *  Purpose: Write out parameters required to 
 *    reinitialize Kalman filter
 *  
 *  Input: o :- archive stream
 *
 *  11.01.2006 djhill1 created
 *******************************************************/
void adet_kf::Archive( ostream& o ) const{
  o << "Window Size: " << _maxWindowSize << endl;
  o << _matrices;
}

/*******************************************************
 *  Purpose: Learn kf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum # iterations
 *
 *  11.15.2006 djhill1 created
 *******************************************************/
 void adet_kf::Learn( const vector< ts_record >& obs, const int maxIter ) {
   vector< matrix< double > > obsMat( obs.size() );
   for( int i=0; i< obs.size(); i++ ){
     obsMat[i] = matrix<double>( obs[i].Data().size(), 1 );
     for( int j=0; j< obs[i].Data().size(); j++ ){
       obsMat[i](j,0) = obs[i].Data()[j];
     }
   }
   TrainBatchEM( obsMat, maxIter);
   
   cout << "Learned Params: \n";
   Archive( cout );
 }

/*******************************************************
 *  Purpose: Learn kf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum # iterations
 *
 *  01.04.2007 djhill1 created
 *******************************************************/
 void adet_kf::Learn( const vector< vector < ts_record > >& obs, const int maxIter ) {
   vector< vector< matrix< double > > > obsMat( obs.size() );
   for( int i=0; i< obs.size(); i++ ){
     obsMat[i] = vector< matrix< double > >( obs[i].size() );
     for( int j=0; j< obs[i].size(); j++ ){
       obsMat[i][j] = matrix<double>( obs[i][j].Data().size(), 1 );
       for( int k=0; k< obs[i][j].Data().size(); k++ ){
         obsMat[i][j](k,0) = obs[i][j].Data()[k];
       }
     }
   }
   TrainBatchEM( obsMat, maxIter);
   
   cout << "Learned Params: \n";
   Archive( cout );
 }
 
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//  class adet_rbpf
//    Rao-Blackwellized Particle Filter
//     for anomaly detection
//
//  11.01.2006 djhill1 created
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
adet_rbpf::adet_rbpf(): bayes_filter(), rbpf() { }

adet_rbpf::adet_rbpf( istream& o ) {
   string arb;
   int numParticles, windowsize;
   rbpf_params temp_params;
   o >> arb >> arb >> arb; // "Number of Particles: " 
   o >> _NP; //numParticles;
   o >> arb >> arb; //"Window Size:"
   o >> _maxWindowSize; //windowsize;
   o >> arb >> arb; // "RBPF params: \n"
   o >> _matrices;
   //this->Archive( cout );
}
    
adet_rbpf::adet_rbpf( const string& s ) {
  ifstream file( s.c_str() );
  if( !file ){
    cerr << "Cannot open file: " << s << endl;
    exit( -1 );
  }
  *this = adet_rbpf( file );
  file.close();
}

/*******************************************************
 *  Purpose: Update and calculate filtered estimate
 *    of system state
 *  
 *  Input: obs :- observation
 *         a :- Bayesian credible interval 
 *             (Bayesian Posterior Interval)
 *             scale arameter
 *
 *  11.01.2006 djhill1 created
 *******************************************************/
 vector< vector< float > > adet_rbpf::Filter( const vector< float >& obs, const float& a ) {
   matrix< double > obsMat( obs.size(), 1 );
   for( int i=0; i< obs.size(); i++ ){
     obsMat(i,0) = obs[i];
   }
   //cout << "New Observation: \n" << obsMat << endl;
   StepForward( obsMat );
   //cout << "Current MAP D value: " << CurrentMAPDValue() << endl;
   vector< vector< float > > returnVal( obs.size() );
   for( int i=0; i< returnVal.size(); i++ ){
     returnVal[i] = vector< float >( 5 );
     returnVal[i][0] = obs[i]; // observation(i)
     returnVal[i][1] = CurrentMAPKFMean()(i,0)-a*sqrt( CurrentMAPKFCov()(i,i) ); // lower bound of observation(i)
     returnVal[i][2] = CurrentMAPKFMean()(i,0); // mean of observation(i)
     returnVal[i][3] = CurrentMAPKFMean()(i,0)+a*sqrt( CurrentMAPKFCov()(i,i) ); // upper bound of observation(i)
     //returnVal[i][4] = CurrentMAPDValue(); // discrete value of observation(i)
     if( CurrentMAPDValue() == 0 && !isnan( obs[i] ) ) returnVal[i][4] = 1.; // z=0 is no error status && obs==NaN
     else if( isnan( obs[i] ) ) returnVal[i][4] = -1.;
     //else returnVal[i][4] = 0.;
     //else returnVal[i][4] = CurrentMAPDValue()+10;
     // Specific to 2 states
     else if( CurrentMAPDValue() == 1 ){
       if( i==0 ) returnVal[i][4] = 0.;
       else returnVal[i][4] = 1.;
     }
     else if( CurrentMAPDValue() == 2 ){
       if( i==1 ) returnVal[i][4] = 0.;
       else returnVal[i][4] = 1.;
     }
     else returnVal[i][4] = 0.;
   }
   return( returnVal );
 }

/*******************************************************
 *  Purpose: Write out parameters required to 
 *    reinitialize Rao-Blackwellized filter
 *  
 *  Input: o :- archive stream
 *
 *  11.01.2006 djhill1 created
 *******************************************************/
void adet_rbpf::Archive( ostream& o ) const{
   o << "Number of Particles: " << _NP << endl;
   o << "Window Size: " << _maxWindowSize << endl;
   o <<"RBPF params: \n";
   o << _matrices;
}

/*******************************************************
 *  Purpose: Learn rbpf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum number of iterations
 *
 *  11.15.2006 djhill1 created
 *******************************************************/
 void adet_rbpf::Learn( const vector< ts_record >& obs, const int maxIter ) {
 
 }

 /*******************************************************
 *  Purpose: Learn rbpf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum # iterations
 *
 *  01.04.2007 djhill1 created
 *******************************************************/
 void adet_rbpf::Learn( const vector< vector < ts_record > >& obs, const int maxIter ){
 
 }
 
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//  class adet_rbpf2
//    Rao-Blackwellized Particle Filter with multiple 
//     discrete variables for anomaly detection
//
//  01.29.2007  djhill1  created
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
adet_rbpf2::adet_rbpf2(): bayes_filter(), rbpf2() { }

adet_rbpf2::adet_rbpf2( istream& o ) {
   string arb;
   int numDiscreteVariables;
   o >> arb >> arb >> arb; // "Number of Particles: " 
   o >> _NP; //numParticles;
   //cout << "Number of Particles: " << _NP << endl;
   o >> arb >> arb; //"Window Size:"
   o >> _maxWindowSize; //window size;
   //cout << "Window Size: " << _maxWindowSize << endl;
   o >> arb >> arb >> arb >> arb;// "Number of Discrete Variables: "
   o >> numDiscreteVariables;
   //cout << "Number of Discrete Variables: " << numDiscreteVariables << endl;
   _components = vector< rbpf_params >( numDiscreteVariables );
   o >> arb >> arb >> arb >> arb >> arb >> arb; // "Number of Observed Linear Gaussian Variables:"
   int numOLGV;
   o >> numOLGV;
   //cout << "Number of Observed Linear Gaussian Variables: " << numOLGV << endl;
   _discreteKey = vector< int >( numOLGV );
   o >> arb >> arb; //"Discrete Key: ";
   //cout << "Discrete Key: ";
   for( int i=0; i< numOLGV; i++ ){
     o >> _discreteKey[i];
     //cout << setw(5) << _discreteKey[i];
   }
   //cout << endl;
   for( int i = 0; i < _components.size(); i++ ){
     o >> arb >> arb >> arb; // "Discrete Variable i";
     o >> arb >> arb; // "RBPF components: \n"
     o >> _components[i];   
     //cout << "Discrete Variable " << i << endl;
     //cout << "RBPF components: \n" << _components[i] << endl << endl;
   }
   _matrices = pcube( _components );
   //this->Archive( cout );
}
    
adet_rbpf2::adet_rbpf2( const string& s ) {
  ifstream file( s.c_str() );
  if( !file ){
    cerr << "Cannot open file: " << s << endl;
    exit( -1 );
  }
  *this = adet_rbpf2( file );
  file.close();
}

/*******************************************************
 *  Purpose: Update and calculate filtered estimate
 *    of system state
 *  
 *  Input: obs :- observation
 *         a :- Bayesian credible interval 
 *             (Bayesian Posterior Interval)
 *             scale arameter
 *
 *  01.29.2007  djhill1  created
 *******************************************************/
 vector< vector< float > > adet_rbpf2::Filter( const vector< float >& obs, const float& a ) {
   matrix< double > obsMat( obs.size(), 1 );
   for( int i=0; i< obs.size(); i++ ){
     obsMat(i,0) = obs[i];
   }
   //cout << "New Observation: \n" << obsMat << endl;
   StepForward( obsMat );
   //cout << "Current MAP D value: " << CurrentMAPDValue() << endl;
   vector< vector< float > > returnVal( obs.size() );
   for( int i=0; i< returnVal.size(); i++ ){
     returnVal[i] = vector< float >( 5 );
     returnVal[i][0] = obs[i]; // observation(i)
     returnVal[i][1] = CurrentMAPKFMean()(i,0)-a*sqrt( CurrentMAPKFCov()(i,i) ); // lower bound of observation(i)
     returnVal[i][2] = CurrentMAPKFMean()(i,0); // mean of observation(i)
     returnVal[i][3] = CurrentMAPKFMean()(i,0)+a*sqrt( CurrentMAPKFCov()(i,i) ); // upper bound of observation(i)
     //returnVal[i][4] = CurrentMAPDValue(); // discrete value of observation(i)
     if( isnan( obs[i] ) || _discreteKey[i] == -1 ) returnVal[i][4] = -1.;  // cannot classify
     else{
       if( CurrentMAPDValue()[_discreteKey[i]] == 0 ){
         // z=0 is no error status
         returnVal[i][4] = 1.;  // no error
       }
       else{
         // MAP state is abnormal
         returnVal[i][4] = 0.;
       }
     }
     //else returnVal[i][4] = float( CurrentMAPDValue()[_discreteKey[i]] );
   }
   return( returnVal );
 }

/*******************************************************
 *  Purpose: Write out parameters required to 
 *    reinitialize Rao-Blackwellized filter
 *  
 *  Input: o :- archive stream
 *
 *  01.29.2007  djhill1  created
 *******************************************************/
void adet_rbpf2::Archive( ostream& o ) const{
   o << "Number of Particles: " << _NP << endl;
   o << "Window Size: " << _maxWindowSize << endl;
   o << "Number of Discrete Variables: " << _matrices.NumDiscVar() << endl;
   o << "Number of Observed Linear Gaussian Variables: " << _discreteKey.size() << endl;
   o << "Discrete Key: ";
   for( int i = 0; i < _discreteKey.size(); i++ ){
     o << setw(5) << _discreteKey[i];
   }
   o << endl;
   for( int i=0; i< _components.size(); i++ ){
     o << "Discrete Variable " << i << endl;
     o << "RBPF components: \n";
     o << _components[i];
   }
}

/*******************************************************
 *  Purpose: Learn rbpf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum number of iterations
 *
 *  01.29.2007  djhill1  created
 *******************************************************/
 void adet_rbpf2::Learn( const vector< ts_record >& obs, const int maxIter ) {
 
 }

 /*******************************************************
 *  Purpose: Learn rbpf_params from observation data
 *  
 *  Input: obs :- observation vector
 *         maxIter :- maximum # iterations
 *
 *  01.29.2007  djhill1  created
 *******************************************************/
 void adet_rbpf2::Learn( const vector< vector < ts_record > >& obs, const int maxIter ){
 
 }
